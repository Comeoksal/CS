## 📌5장 소켓 옵션

### ➡️참고용 소켓 옵션

참고 : 연결용 소켓이 가지고 있는 옵션 내용은 accept()가 리턴하는 통신용 소켓에 상속됨. 따라서 통신용 소켓에서 필요한 소켓 옵션 지정은 accept 호출 전에 해둬야 함.

- **SO_KEEPALIVE** : 연결이 정상적으로 지속되고 있는지 주기적으로 확인하는 소켓 옵션
1. 상대방이 ACK를 보냄 : 정상 연결
2. 상대방이 RST 에러 보냄 : 호스트가 꺼진 후 재부팅 된 상태
3. 아무 응답 없음 : 질문을 몇 번 더 보낸 후 종료
- **SO_LINGER** : close()를 호출한 이후에 상대방에서도 정상 종료가 이루어졌는지 확인하는 소켓 옵션
1. close()가 리턴 됐다고 해서 상대방에게 데이터가 모두 전송된 것이 보장된 것은 아님
2. 따라서 일정 시간동안 정상 종료가 이루어졌는지 확인함
- **SO_RCVBUF, SO_SNDBUF** : 송수신 최대 버퍼 크기를 통신 시작 때 주고 받아 확인

### ➡️SO_REUSEADDR : 소켓주소 재사용 옵션

**동일한 소켓 주소(IP주소와 포트번호 조합)에 대해**서 여러 프로세스 또는 한 프로세스 내 여러 소켓에서 **중복 사용하는 것을 허용**하는 옵션)

1. TIME-WAIT 상태에서의 주소 재사용 (서비스 즉시 재시작)

Ctrl + C로 강제 종료 시킨 후 재사용시 이미 사용 중인 에러 발생. 이러한 이유는 Time-wait상태에서 2MSL 시간 기다려야함.

1. 자식 프로세스가 서버인 경우

자식 프로세스가 서비스 처리 담당시, 부모 프로세스가 종료되었다가 다시 시작하면 사용 중인 에러 발생.(과거의 자식 프로세스가 해당 포트번호 사용)

1. 멀티홈 서버의 경우

두 개 이상의 랜에 접속된 경우 두 IP를 가짐**. 같은 포트 번호를 사용하면서 둘 이상의 다른 IP주소를 사용할 때**

1. **완전 중복 바인딩**

여러 프로세스 또는 한 프로세스 내 여러 소켓에서 **동일한 IP주소와 동일한 포트번호를 중복하여 bind** 하는 것. **UDP 소켓**에서만 가능하며, **멀티캐스트 데이터그램을 수신**하는 경우에 사용.

**하나의 멀티캐스트 그룹 내에서 여러 멀티캐스트 가입자들이 동일한 데이터그램을 수신하기 위해서 같은 포트번호로 완전 중복 바인딩 된 소켓주소를 사용함.**

### ➡️멀티캐스트

- 멀티캐스트 개념

**송신측에서 하나의 데이터 그램 송신 → 네트워크 내(멀티캐스트 그룹)에서 복제되어 다수의 호스트(멀티캐스트 그룹 가입자들)로 전송됨**

- 멀티캐스트 그룹

멀티캐스트 데이터 그램을 수신하고자 하는 호스트들의 집합

클래스 D의 IP 주소를 그룹 주소로 사용, 특정 멀티캐스트 그룹으로 데이터그램을 전송하려면 그 그룹주소를 목적지로 하여 UDP 데이터그램을 전송

→ 가입 및 통신 과정(중간 라우터들이 MRP(Multicast Routing Protocol)를 실행하고 있어야 함)

가입하려는 호스트는 인접 라우터에게 자신이 멀티캐스트 그룹에 가입한 사실을 알리고 이 라우터가 주변 멀티캐스트 라우터에게 알리며 정보를 저장. 이제 다른 호스트에서 이 멀티캐스트 그룹 주소로 데이터그램을 보내면 멀티캐스트 라우터들은 MRP를 이용하여 모든 가입자에게 데이터그램 전달

멀티캐스트 그룹 주소, 자신의 아이피 주소, 멀티캐스트 공통 포트 번호 필요

- 멀티캐스트 데이터그램 송수신

→송신 : UDP 소켓 개설, 멀티캐스트 그룹 IP 주소, 그룹 공통 포트번호를 통해 데이터그램 전송

→수신 : UDP 소켓 개설, 멀티캐스트 그룹 가입, 소켓주소 재사용 옵션 지정(SO_REUSEADDR)

여러 멀티캐스트 수신자에 의해 그룹IP + 포트번호로 여러 수신자가 해당 정보를 가진 소켓을 중복 사용하기 떄문

```c
//1. 수신용 UDP 소켓 개설
recv_s = socket(AF_INET. SOCK_DGRAM, 0);
//2. 멀티캐스트 그룹 가입(구조체 mreq에 멀티캐스트 정보 저장되어 있음)
setsockopt(recv_s, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
//3. 소켓 주소 재사용 옵션 지정
unsigned int set = 1;
setsockopt(recv_s, SOL_SOCKET, SO_REUSEADDR, &set, sizeof(set));
//4. 소켓 바인드
bind(recv_s, (struct sockaddr*)&mcast_group, sizeof(mcast_group));
```

---

## 📌12장 TCP/IP 프로토콜

### ➡️이더넷(네트워크 액세스 계층)

> DA, SA는 수신지 및 송신지의 MAC 주소, MAC 주소(물리 주소)는 이더넷 카드마다 범세계적으로 유일하게 지정되는 고유번호
>

> CSMA/CD 프로토콜을 사용, 프레임을 전송할 때 채널 감지(CSMA) 채널이 사용중이 아닐 때만 전송.
>

전송 중에 혹시 타 장비가 전송하여 충돌이 나는지 감시(CD), 충돌이 나면 전송 중지.

CSMA/CD와 같은 MAC 프로토콜은 하나의 전송 매체를 여러 장비가 공유하기 위해 사용.

이는 허브, 스위칭 허브로 대체됨

### ➡️IP 프로토콜 (IP 계층)

> 서브네트워크를 이용하여 IP 데이터그램을 임의의 호스트 사이에 전달하는 기능 수행
>

IP계층은 비연결형 방식으로, 단순히 목적지로 전달하기 위해 노력만 함

가장 큰 특징은 전 세계에 흩어져 있는 호스트를 4바이트의 IP 주소로 쉽게 찾아 데이터 전달

- IP 데이터그램 헤더(자세한 내용은 책 참고)
1. Total Length : IP 데이터그램 전체 크기
2. Identification : 단편화되는 여러 데이터그램은 모두 같은 값을 가짐
3. Flags : 첫 비트 미사용, DF(단편화 금지 0:허용, 1:금지), More(0:마지막 데이터그램, 1:연속되는 데이터그램) More 1부터 1, 1, 1, … , 0까지 재조립 대상
4. Fragment Offset :전체 메시지 중 이 데이터그램의 위치 표시(재조립시 사용)
5. TTL : 데이터그램이 인터넷에 돌아다닐 수 있는 시간값
6. Source IP address, Destination IP address : 송신지, 수신지 IP주소

☑️IP 주소의 특징

4바이트 크기를 가지며, dotted decimal IP 주소 표현을 주로 사용(192.168.0.1 등)

netid와 hostid로 구분되며, 각 필드가 사용하는 비트 수의 크기에 따라 네 클래스로 구분

클래스 D는 주로 멀티캐스트 주소로 사용된다.

☑️MTU

IP 계층의 기본 기능은 상위 계층으로부터 받은 메시지에 IP 헤더를 붙여 IP 데이터그램을 만들어 전송하는 것. 데이터그램을 실제로 전달할 통신망인 **서브네트워크가 한 번에 전달할 수 있는 데이터그램의 최대 크기를 MTU**(Maximum Transmission Unit)이라고 한다.

☑️path MTU

두 호스트가 인터넷으로 연결되기 위해서 **여러 서브네트워크를 경유**할 수 있는데, **서브네트워크들의 각 MTU 중 최소값을 두 호스트 사이의 path MTU**라고 한다.

IP계층은 상위 계층으로부터 받은 메시지 크기가 pathMTU보다 큰 경우 이를 여러 데이터그램으로 단편화하여 전송하고, 수신측은 재조립한다.

DF를 1로 세트하면 단편화를 금지하는데, 데이터 그램의 크기가 pathMTU보다 클 경우 중간 라우터가 에러를 발생하며 송신측에게 알려준다. **일반적으로 DF비트는 0이기 때문에 pathMTU를 알 필요가 있고**, 이는 **DF를 1로 세트하여 수신측에 전송하면서 에러가 발생하지 않을 때까지 데이터그램의 크기를 줄이면서 pathMTU를 찾을 수 있다.**

☑️라우팅

라우팅이란 IP 데이터그램이 목적지 호스트까지 전달되기 위해서 라우터를 거쳐서 찾아가는 경로를 정해주는 기능을 의미. (라우팅을 처리하는 장비를 라우터라고 함)

라우팅 테이블이란 **라우팅 알고리즘으로 얻은 라우팅 정보를 정리**한 것이며, 라우터는 이 라우팅 테이블을 보고 **어떤 인접 라우터로 전송해야 최적인지 판단한 후 전송**한다.

### ➡️TCP 프로토콜

☑️TCP 특징

1. 연결형 서비스 제공 : ACK을 통한 연결 설정을 함
2. 신뢰성 있는 데이터 전달 보장 : 확인 응답
    - 확인 응답(ACK)은 데이터가 목적지에게 잘 전달되었다고 수신측에서 전송측에게 확인하기 위해서 보내며, **문제가 없으면 송신측으로 ACK을 보내게 된다**. 수신측에서 데이터를 받을 때마다 ACK을 보내면 불필요하게 많은 ACK이 발생하기 때문에, 지연시간을 두고 자신이 보낼 데이터가 있다면 이 데이터에 ACK 기능을 추가하여 보낸다.
3. 바이트 스트림 제공

☑️TCP 세그먼트

TCP 계층이 IP 계층으로 내려보내는 데이터 단위를 세그먼트라고 하며, 종점간 TCP들 사이에 송수신 되는 단위이다.(헤더 + 데이터)

☑️TCP 헤더

Sequence Number : 송신 데이터의 순서번호(바이트 단위) 만약 501번 값에 100바이트 데이터가 담겨 있으면 다음 읽을 SN는 601이 될 것. 이 값을 ACK number에 저장하여 송신측으로 전달함으로써 600번 순서번호까지 데이터가 정상적으로 목적지에 도착한 것을 알림.

☑️TCP 연결 설정

3-way handshake

1. 연결 요청측에서 SYN 비트를 세트하고 Sequence Number를 랜덤 정수 X로한 연결 요청을 보냄
2. 수신 측에서 ACK 비트를 세트하고 Ack Number에(X+1), 동시에 SYN비트도 세트하고 똑같이 랜덤 정수 Y로 하여 보냄
3. 이를 받은 수신측에서 Ack(Y+1)로 응답하면 연결 요청 성공

☑️TCP 연결 종료

1. 연결 종료 요청 측에서 FIN 비트를 세트하고 랜덤 정수K를 담아 연결 종료를 보냄
2. 수신 측에서 ACK(K+1)을 보냄
3. 조금 후에 자신도 FIN(L)을 보냄
4. FIN을 받은 연결 종료 요청측은 ACK(L+1)을 보냄으로써 연결 종료 확인(이후 2MSL 시간동안 Time wait 상태에 들어감)

☑️Time Wait 상태

상대방이 내가 보낸 FIN(연결 종료 요청)에 대한 응답 시간을 대기하며 모든 연결 종료를 완료하기 위해서 존재함

과거의 연결에서 전송되었던 세그먼트가 어떤 이유로 늦게 도착하는 것을 잘못 수신할 수 있기 떄문에 같은 IP주소와 포트번호로 재사용 즉시 불가.

가능하면 클라이언트가 active close 요청을 하는 것이 바람직한데, 그래야 서버측이 time-wait 상태에 들어가지 않고 같은 포트번호로 다른 서비스의 요청에 응답할 수 있다.(passive close 측은 time-wait 상태가 없기 때문 내 FIN에 대한 ACK을 받으면 끝이라서)

☑️MSS

MTU : 서브네트워크가 한 번에 전송할 수 있는 최대 데이터 크기

path MTU : 종점 호스트 사이에 존재하는 서브네트워크들의 MTU중 최소값

MSS : IP 계층에서의 단편화를 피하기 위해 지정한 최대 세그먼트 크기 MSS

MSS = pathMTU - (IP 헤더 크기 + TCP 헤더 크기)

☑️TCP 데이터 송수신

TCP는 송수신 버퍼를 각각 가지고 있음. 상대방으로부터 전송 확인 응답인 ACK이 오기전까지 데이터는 송신버퍼에 보관되는데, 이는 재전송을 하기 위함.

write문은 성공시 데이터가 네트워크 상으로 송신된 것이 아니며, 목적지에 도착했는지는 알 수 없다. 전송할 데이터가 송신 버퍼에 복사만되면 리턴하는 것을 주의.

☑️흐름제어

수신측 : 수신 버퍼의 여유 크기를 고려해 상대방이 보낼 수 있는 데이터 량을 바이트 단위로 알려줌

송신측 : 송신 버퍼가 부족해지면 쓰기 함수가 블록됨으로써 알려줌

☑️혼잡 제어

1. 일정한 시간 내에 Ack가 오지 않으면 네트워크 혼잡이 발생한 것으로 판단
2. 같은 메시지에 대한 Ack을 계속 보내옴

### ➡️UDP 프로토콜

☑️UDP 특징

1. 데이터 분실 확인 x, 전달 순서 보장 x
2. 헤더 크기가 작고, 연결 지연이 없음(간단한 데이터 주고받기에 유리)
3. 방송 또는 멀티캐스트에 주로 사용
4. MTU 크기 제한에 의해 여러개의 IP 데이터그램으로 단편화되어 전송(단편화를 피하는 것이 안전하긴 함)

☑️UDP 헤더

- 송신지 포트번호
- 수신지 포트번호
- 데이터그램 길이
- 첵섬
- 데이터