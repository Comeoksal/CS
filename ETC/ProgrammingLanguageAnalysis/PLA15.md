# 15장 : 함수형 프로그래밍 언어

## 1. 함수형 언어의 정의

<aside>
💡

함수형 언어는 프로그램을 함수의 조합으로 구성하여 계산을 수행하는 선언형 프로그래밍

</aside>

명령어로 상태를 바꾸기보다, **데이터를 입력받아 새로운 값을 반환**하는 함수 중심의 방식으로 로직을 구성

## 2. 함수형 언어의 특징(5가지)

### 1. **순수 함수 (Pure Function)**

- 동일한 입력 → 항상 동일한 출력
- 함수 외부의 상태에 의존하거나 변경하지 않음
- 예: `f(x) = x + 1`

### 2. 불변성 (Immutability)

- 변수나 데이터 구조는 한 번 정의되면 변경하지 않음
- 새로운 값을 만들고 반환함 → 부작용(side effect) 방지

### 3. 일급 함수 (First-class Function)

- 함수는 변수에 할당, 인자로 전달, 반환값으로 사용 가능
- 함수도 값처럼 다루는 것이 기본

### 4. 고차 함수 (Higher-order Function)

- 함수를 인자로 받거나 함수를 반환하는 함수
- map, filter, reduce 같은 고차 함수는 필수

### 5. 선언형 스타일 (Declarative Style)

- **무엇**을 해야 하는지 설명 → **어떻게**는 추상화
- 반복, 조건 처리 등도 추상화된 함수로 표현

---

## 1. Lisp 언어의 배경 및 특징

### ➡️동적타입 : 변수 선언시에 타입이 불필요하고 동적으로 타입을 결정한다.

### ➡️재귀 사용 : 반복보단 재귀를 사용한다. 맨 처음 개발된 Lisp에는 반복문 자체가 구현되어 있지 않다.

### ➡️리스트 중심 구조 : 모든 데이터와 코드가 리스트의 형태를 가지고 있다. 이는 다음 특징인 Homoiconicity 와 밀접한 연관이 있다.

### ➡️Homoiconicity: 코드 = 리스트 = 데이터 라는 큰 특징을 가지고 있다. 이는 작성한 코드가 데이터로 취급되어 다른 코드에도 사용될 수 있고 그렇게 작성한 코드 또한 데이터가 될 수 있다는 말이 된다.

## 2. Lisp 언어의 특징별 코드 데모 3가지

1. 덧셈 예제 ( 리스트형 구조, 동적 타입 )

### ➡️let, setf, setp = 변수 선언 함수

1번째 줄에 let으로 변수 x, y 에 5와 10이라는 값을 할당했다.

그 이후 setf 라는 함수로 x를 문자열 이라는 값으로 바꾸었다.

동적 타입을 사용하기 때문에 5가 정수라는 것과 상관 없이 x는 문자열로 바뀌게 된다.

### ➡️format, eval

format은 출력 함수이다 ~A는 뒤 인자를 출력하는 함수이고  ~%는 줄 바꿈이다.

eval은 리스트 형태의 코드를 받아 실행시키는 함수이다. 즉 코드가 실행된 값을 가져 와주는 함수이다.

1. mapcar, 람다식 예제

### ➡️mapcar

mapcar란 함수를 뒤 리스트의 각 요소에 적용하여 새 리스트를 반환하는 함수이다.

#’는 뒤에 square가 함수임을 명시하는 뜻이다.

### ➡️lamda

lamda = 일회용 익명 함수

함수를 미리 정의하지 않고 리스트 안에서 임시로 함수를 만들어 사용한다.

프로그래밍 언어에서 Lamda식을 표현한 것은 Lisp 가 최초이다.

### 4. Scheme? Common Lisp?

lisp 의 파생언어 즉, 사투리는 lisp-1 과 lisp-2 로 구분된다.

| 구분 | Scheme | Common Lisp |
| --- | --- | --- |
| 개발 철학 | 미니멀리즘, 핵심기능 집중 | 실용중심적 |
| 네임 스페이스 | Lisp-1(네임스페이스 공유) | Lisp-2(네임스페이스 분리) |
| 불리언 표현 | 빈 리스트를 “참”으로 취급 | 빈 리스트를 “거짓”으로 취급 |
| 문법 | 단순하고 일관됨 | 복잡하지만 강력함 |

두 언어 모두 Lisp의 큰 특징을 따라가지만 세부적인 부분에서 차이가 있다.

1. Scheme의 함수와 변수는 네임스페이스를 공유한다. 하지만 Common Lisp는 네임스페이스를 분리하여 변수인지 함수인지 명시를 해주어야 한다.
2. 빈 리스트 인 “()” 를 Scheme에서는 참으로 취급하고 Common Lisp 에서는 “거짓”으로 취급한다.
3. Scheme의 문법은 단순하여 메크로의 기능이 강화되어있다. 새로운 함수를 만들고 사용하는것이 자유롭고 Common lisp에도 메크로 기능이 있으나 Scheme 만큼 강력하진 않다.

---

## 1. Haskell 언어의 배경 및 특징

### 특징1. 순수 함수형 : 모든 함수는 입력에만 의존하고, 외부 상태에 영향을 주지 않음

(외부 상태란 해당 코드 블록 외부로부터 영향을 받거나 또는 주는 행위 ex) 파일 입출력 작업, DB 작업 등)

### 특징2. 지연 평가 : 값은 실제로 필요할 때만 계산 됨. 인자 사용 여부에 관여를 함(무한 구조 가능)

(엄격 평가란 함수에 인자가 전달되면, 그 즉시 인자를 평가(계산)하는 방식. 인자 사용 여부 무관)

### 특징3. 강력한 타입 시스템 : Hindley-Milner 기반의 타입 추론 + 고차 다형성 등 지원

---

## 2. Haskell 언어의 특징별 코드 데모 3가지

### 📌순수함수형

### 순수 함수형이란..

- **외부 상태 변경 불가(외부 상태로부터 영향을 받아서도 안 됨)**
- **전역 변수 수정 안 됨**
- **항상 같은 입력 → 같은 결과**

**“순수한 계산은 함수로, 부작용은 IO로 명확히 나누자” << Haskell 언어 철학**

### 📌지연 평가

무한은 실제로 존재할 수 없지만, 반환값으로 정의될 수 있음. 이는 무한 리스트를 미리 만들어 놓는 것이 아닌 요청되는 만큼만 생성하는 지연 평가적 특성 때문에 가능

print (safe boom)시에 safe 함수의 인자인 boom 함수를 호출하면 error가 발생하는 것이 일반적이지만, safe함수는 인자 여부에 상관없이 항상 1을 반환하기 때문에 1이 출력. 이는 값이 필요할 때만 실제로 사용되는 지연 평가적 특성 때문에 가능

### 강력한 타입 시스템

**Hindley-Milner 라는 강력한 타입 시스템을 사용**

1. **컴파일 단계에서 모든 타입 체크 완벽 수행(정적 타입 검사)**
2. **컴파일러가 타입 자동 추론**
3. **같은 함수가 여러 타입에 대해 동작 가능(다형성)**
4. **구체적인 타입을 추상화해서 일반적 타입 도출(일반화)**
5. **항상 하나의 가장 일반적인 타입 도출(결정적 추론)**

## 4. Haskell vs ML

|  | Haskell | ML |
| --- | --- | --- |
| 패러다임 | 순수 함수형 | 함수형 + 명령형 |
| 평가전략 | 지연 평가 | 엄격평가 |
| 부작용 허용 여부 | 직접 부작용 불가 | 부작용허용 |
| 가변 변수 | 없음 | 있음 |
1. Haskell은 철저하게 수학적 함수처럼 동작하는 순수 함수형 언어. ML은 함수형을 기본으로 하지만 명령형 스타일(변수 변경, 루프 등) 지원
2. **Haskell은 값이 실제로 필요할 때까지 계산을 미루는 지연 평가 방식. ML은 함수의 인자가 호출 즉시 평가되는 엄격 평가 방식.**
3. Haskell은 IO, 상태 변경 등 부작용을 직접 허용x, 반드시 Monad(IO, State 등) 안에서 명시적 처리. ML은 ref, print 등으로 명령형 스타일 부작용 허용

   (그렇다면 Haskell도 허용하는 것이 아닌가? → 아님. Haskell은 언어 철학 적으로 “부작용을 허용하지 않으나, 필요한 경우에 사용해라”인 것이고 다른 언어들은 일부 허용하는 형태로 키워드를 열어둠)

4. Haskell의 변수는 한 번 정의되면 절대 변경 불가. ML은 ref, mutable 등을 통해 값을 나중에 바꾸는 변수를 지원.