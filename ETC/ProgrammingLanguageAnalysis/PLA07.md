# 7장 : C++, Java, Python

## 📌 C++

- **정적 , 스택-동적 클래스** (값을 통한 참조) 함수 종료시 소멸
- **힙-동적 클래스** (포인터를 통해 참조) new→delete
1. **멤버 함수는 묵시적 인라인 함수**(호출, 복귀 필요없음)
2. 접근 지정자 존재
3. 생성자는 **객체 생성시 묵시적 호출** (오버로딩 필요)
4. **소멸자는 클래스의 존속기간이 끝날 때 묵시적 호출**

**캡슐화의 목적**

1. 데이터 보호 **(외부로부터 내부의 데이터 보호)**
2. 인터페이스 제공 **(객체를 사용할 수 있는 인터페이스 제공)**
3. **유지보수 용이성**

명칭 캡슐화의 문제를 다루는 **namespace 존재(선언한 공간에서만 유효하게 함)**

## 📌Java

**모든 객체는 힙에서 할당,** 참조 변수를 통해 접근

**메소드는 몸체와 머리부가 함께**(인터페이스 제외)

자바는 모든 객체에 대해 가비지 컬렉터 사용(객체 회수 문제와 메모리 등 무시 가능)

컬렉션 클래스 : ArrayList, 포괄형 클래스 MyClass<T> 가능

- **인터페이스 : 다중 상속 가능, 메서드 시그니처만 정의**
- 추상 클래스 : **일부 구현 가능,** **단일 상속(중요) << 다수의 추상 클래스로부터 상속 받기 불가**

## 📌Python

class 키워드를 이용해 선언, 생성시 힙에 할당(참조 변수 접근) << 자바와 동일

**__init__으로 생성자** 지정 **__del__으로 소멸자** 지정

메소드 선언은 함수와 같이 def를 이용해 선언

생성자의 첫 매개변수에는 객체 자신을 받는 변수 self (다른 언어의 this) 필요

기본적으로 모두 public 접근 지정자를 가짐, 변수나 메소드 앞에 _를 붙여서

_ 1개 : protected, _ 2개 : private << 특징 중요

- 동적 타이핑 존재, 상속 및 다형성 가능

---

### (3) 7장 연습문제 17번, 18번

17번 문제 설명 : 프로그래밍 언어에서 자동 타입 변환이 포함되어야 하는가? 그 이유도 제시
앞의 문제에서 볼 수 있듯이 타입 강제 변환 규칙은 그 편리함 때문에 원하
지 않는 결과를 초래하고, 유익한 효과를 약화 시키기도 합니다. 그렇다면 과
면 이러한 타입 변환을 넣은 이유가 무엇인지, 타입 변환의 장점을 알아보았습
니다. 특히 문제에서 묻는 자동 타입 변환(암시적 형 변환)이 포함되어야 하는
지 위주로 작성했습니다. 1. 코드의 간결성
자동 타입 변환이 있다면 개발자로부터 불필요한 코드 작성을 줄일 수 있게
해줍니다. 만약 개발자가 해당 언어의 자동 타입 변환 원리 및 결과를 이해하
고, 이를 잘 활용한다면 코드의 가독성 및 생산성을 높일 수 있습니다. 2. 초보 개발자, 약 타입 언어에 익숙한 개발자에게 친화적
타입 규칙에 대해 익숙하지 않은 초보 개발자 또는 약 타입 언어(js, python
등)에 익숙한 개발자들에게 자동 타입 변환은 친화적이게 다가오며, 학습성을
향상시킬 수 있습니다. 결론. 이처럼 자동 타입 변환은 단점도 가지는 반면 위를 포함한 여러 이점들
을 가지기도 합니다. 효과적으로 도입한다면 강타입 언어의 이점을 해치지 않
으면서 유연한 언어 특성을 확보할 수 있습니다. 이러한 장단점을 고려하여
Java, C#과 같이 강 타입 언어에서도 자동 형 변환을 도입한 것을 보면 자동
형 변환은 부분적으로 필요해보입니다. 추가적으로 명시적 형 변환의 장점은
아래와 같습니다.

- 논리적인 코드 확인 : 명시적 형 변환을 통한 코드 논리 확인(내가 잘못된
  타입으로 작성한 것이 아닌지)
- 개발자의 의도 확인 및 협업 효율 증가 : 명시적으로 형 변환을 하는 것을
  코드상으로 작성함으로써 컴파일러가 개발자의 의도를 확인할 수 있고, 협업
  과정에서 직관적으로 팀원의 의도를 확인할 수 있습니다.

18번 문제 설명 : C 또는 C++의 최적화 컴파일러가 불리안 식에 포함된 부분 식의 평가 순서를 변경하는 것을 허용해야 하는가? 그 이유도 제시
->책의 7.6절을 보면 단락회로 평가에 대한 설명이 있습니다. 이를 간략하게
설명하자면, if((a>=0 && (b<10))과 같은 if문이 있을 때, 만약 실제 a값이 0
보다 작다면 b. 상수 10, 관계 연산자 &&와 같은 값들은 컴파일러가 평가할
필요도 없게 됩니다. 단락회로 평가는 컴파일러를 만드는 데에 있어서 생각할
부분이 많아지고, 복잡성도 증가하게 됩니다. 18번 문제의 요지는 이러한 성능
을 최적화하기 위해서 단락회로 평가를 하지 않게 구현해도 되는가?를 묻는
것입니다. 제가 생각하기에는 C 또는 C++ 컴파일러를 이해하고, 내부에 정의
된 규칙에 어긋나지 않는 선에서 최적화 컴파일러를 만들어도 될 것 같습니다. 다만 컴파일러 내부 규칙을 모두 이해하기는 상당히 어렵고, 이는 의도치 않은 결과 또는 부작용으로 이어질 수 있기 때문에 신중해야할 것 같습니다.